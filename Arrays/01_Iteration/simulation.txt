================================================================================
                        ARRAY ITERATION - STEP-BY-STEP SIMULATION
================================================================================

OVERVIEW:
This simulation demonstrates how array iteration works internally, showing
each step of the process with detailed explanations and memory representations.

SAMPLE ARRAY: [10, 25, 3, 47, 12, 89, 5, 33]
Array Length: 8
Index Range: 0 to 7

MEMORY LAYOUT:
Index:  [0] [1] [2] [3] [4] [5] [6] [7]
Value: [10][25][ 3][47][12][89][ 5][33]

================================================================================
                           FORWARD ITERATION SIMULATION
================================================================================

ALGORITHM:
for (int i = 0; i < length; i++) {
    print(array[i]);
}

STEP-BY-STEP EXECUTION:

INITIALIZATION:
- Set loop counter i = 0
- Check condition: i < 8 → 0 < 8 → TRUE

ITERATION 1:
- Current i = 0
- Access array[0] = 10
- Print: 10
- Increment: i = i + 1 = 1
- Check condition: i < 8 → 1 < 8 → TRUE

ITERATION 2:
- Current i = 1
- Access array[1] = 25
- Print: 25
- Increment: i = i + 1 = 2
- Check condition: i < 8 → 2 < 8 → TRUE

ITERATION 3:
- Current i = 2
- Access array[2] = 3
- Print: 3
- Increment: i = i + 1 = 3
- Check condition: i < 8 → 3 < 8 → TRUE

ITERATION 4:
- Current i = 3
- Access array[3] = 47
- Print: 47
- Increment: i = i + 1 = 4
- Check condition: i < 8 → 4 < 8 → TRUE

ITERATION 5:
- Current i = 4
- Access array[4] = 12
- Print: 12
- Increment: i = i + 1 = 5
- Check condition: i < 8 → 5 < 8 → TRUE

ITERATION 6:
- Current i = 5
- Access array[5] = 89
- Print: 89
- Increment: i = i + 1 = 6
- Check condition: i < 8 → 6 < 8 → TRUE

ITERATION 7:
- Current i = 6
- Access array[6] = 5
- Print: 5
- Increment: i = i + 1 = 7
- Check condition: i < 8 → 7 < 8 → TRUE

ITERATION 8:
- Current i = 7
- Access array[7] = 33
- Print: 33
- Increment: i = i + 1 = 8
- Check condition: i < 8 → 8 < 8 → FALSE

TERMINATION:
- Loop ends when condition becomes false
- Final output: 10 25 3 47 12 89 5 33

================================================================================
                          BACKWARD ITERATION SIMULATION
================================================================================

ALGORITHM:
for (int i = length - 1; i >= 0; i--) {
    print(array[i]);
}

STEP-BY-STEP EXECUTION:

INITIALIZATION:
- Set loop counter i = length - 1 = 8 - 1 = 7
- Check condition: i >= 0 → 7 >= 0 → TRUE

ITERATION 1:
- Current i = 7
- Access array[7] = 33
- Print: 33
- Decrement: i = i - 1 = 6
- Check condition: i >= 0 → 6 >= 0 → TRUE

ITERATION 2:
- Current i = 6
- Access array[6] = 5
- Print: 5
- Decrement: i = i - 1 = 5
- Check condition: i >= 0 → 5 >= 0 → TRUE

ITERATION 3:
- Current i = 5
- Access array[5] = 89
- Print: 89
- Decrement: i = i - 1 = 4
- Check condition: i >= 0 → 4 >= 0 → TRUE

ITERATION 4:
- Current i = 4
- Access array[4] = 12
- Print: 12
- Decrement: i = i - 1 = 3
- Check condition: i >= 0 → 3 >= 0 → TRUE

ITERATION 5:
- Current i = 3
- Access array[3] = 47
- Print: 47
- Decrement: i = i - 1 = 2
- Check condition: i >= 0 → 2 >= 0 → TRUE

ITERATION 6:
- Current i = 2
- Access array[2] = 3
- Print: 3
- Decrement: i = i - 1 = 1
- Check condition: i >= 0 → 1 >= 0 → TRUE

ITERATION 7:
- Current i = 1
- Access array[1] = 25
- Print: 25
- Decrement: i = i - 1 = 0
- Check condition: i >= 0 → 0 >= 0 → TRUE

ITERATION 8:
- Current i = 0
- Access array[0] = 10
- Print: 10
- Decrement: i = i - 1 = -1
- Check condition: i >= 0 → -1 >= 0 → FALSE

TERMINATION:
- Loop ends when condition becomes false
- Final output: 33 5 89 12 47 3 25 10

================================================================================
                        CONDITIONAL ITERATION SIMULATION
================================================================================

SEARCHING FOR: 47

ALGORITHM:
for (int i = 0; i < length; i++) {
    if (array[i] == target) {
        return true;
    }
}
return false;

STEP-BY-STEP EXECUTION:

ITERATION 1:
- Current i = 0
- Access array[0] = 10
- Compare: 10 == 47? → FALSE
- Continue to next iteration

ITERATION 2:
- Current i = 1
- Access array[1] = 25
- Compare: 25 == 47? → FALSE
- Continue to next iteration

ITERATION 3:
- Current i = 2
- Access array[2] = 3
- Compare: 3 == 47? → FALSE
- Continue to next iteration

ITERATION 4:
- Current i = 3
- Access array[3] = 47
- Compare: 47 == 47? → TRUE
- Found target! Return true
- Print: "Found 47 at index 3"

EARLY TERMINATION:
- No need to check remaining elements
- Efficient search with early exit

================================================================================
                           SUM CALCULATION SIMULATION
================================================================================

ALGORITHM:
sum = 0;
for (int i = 0; i < length; i++) {
    sum = sum + array[i];
}

STEP-BY-STEP EXECUTION:

INITIALIZATION:
- sum = 0

ITERATION 1:
- i = 0, array[0] = 10
- sum = 0 + 10 = 10

ITERATION 2:
- i = 1, array[1] = 25
- sum = 10 + 25 = 35

ITERATION 3:
- i = 2, array[2] = 3
- sum = 35 + 3 = 38

ITERATION 4:
- i = 3, array[3] = 47
- sum = 38 + 47 = 85

ITERATION 5:
- i = 4, array[4] = 12
- sum = 85 + 12 = 97

ITERATION 6:
- i = 5, array[5] = 89
- sum = 97 + 89 = 186

ITERATION 7:
- i = 6, array[6] = 5
- sum = 186 + 5 = 191

ITERATION 8:
- i = 7, array[7] = 33
- sum = 191 + 33 = 224

FINAL RESULT:
- Total sum = 224

================================================================================
                         MAXIMUM FINDING SIMULATION
================================================================================

ALGORITHM:
max = array[0];
for (int i = 1; i < length; i++) {
    if (array[i] > max) {
        max = array[i];
    }
}

STEP-BY-STEP EXECUTION:

INITIALIZATION:
- max = array[0] = 10

ITERATION 1:
- i = 1, array[1] = 25
- Compare: 25 > 10? → TRUE
- Update: max = 25

ITERATION 2:
- i = 2, array[2] = 3
- Compare: 3 > 25? → FALSE
- max remains 25

ITERATION 3:
- i = 3, array[3] = 47
- Compare: 47 > 25? → TRUE
- Update: max = 47

ITERATION 4:
- i = 4, array[4] = 12
- Compare: 12 > 47? → FALSE
- max remains 47

ITERATION 5:
- i = 5, array[5] = 89
- Compare: 89 > 47? → TRUE
- Update: max = 89

ITERATION 6:
- i = 6, array[6] = 5
- Compare: 5 > 89? → FALSE
- max remains 89

ITERATION 7:
- i = 7, array[7] = 33
- Compare: 33 > 89? → FALSE
- max remains 89

FINAL RESULT:
- Maximum value = 89

================================================================================
                           STEP ITERATION SIMULATION
================================================================================

STEP SIZE: 2

ALGORITHM:
for (int i = 0; i < length; i += step) {
    print(array[i]);
}

STEP-BY-STEP EXECUTION:

ITERATION 1:
- i = 0
- Access array[0] = 10
- Print: 10
- Increment: i = 0 + 2 = 2

ITERATION 2:
- i = 2
- Access array[2] = 3
- Print: 3
- Increment: i = 2 + 2 = 4

ITERATION 3:
- i = 4
- Access array[4] = 12
- Print: 12
- Increment: i = 4 + 2 = 6

ITERATION 4:
- i = 6
- Access array[6] = 5
- Print: 5
- Increment: i = 6 + 2 = 8

TERMINATION:
- i = 8, which is >= length (8)
- Loop terminates
- Output: 10 3 12 5

================================================================================
                              PERFORMANCE ANALYSIS
================================================================================

TIME COMPLEXITY:
- Forward/Backward Iteration: O(n)
- Conditional Search: O(n) worst case, O(1) best case
- Sum Calculation: O(n)
- Maximum Finding: O(n)
- Step Iteration: O(n/step)

SPACE COMPLEXITY:
- All operations: O(1) additional space
- Only use a few variables regardless of array size

MEMORY ACCESS PATTERNS:
- Sequential access is cache-friendly
- Predictable memory access pattern
- Good performance on modern CPUs

================================================================================
                               EDGE CASES
================================================================================

EMPTY ARRAY []:
- Length = 0
- Loop condition: i < 0 → FALSE immediately
- No iterations performed
- Default values returned (0 for sum, null for max)

SINGLE ELEMENT [42]:
- Length = 1
- Forward: prints 42
- Backward: prints 42
- Sum: 42
- Max: 42

NULL ARRAY:
- Check for null before any operations
- Return appropriate default values
- Avoid null pointer exceptions

================================================================================
                              BEST PRACTICES
================================================================================

1. BOUNDS CHECKING:
   - Always verify array is not null
   - Check array length before accessing

2. LOOP INVARIANTS:
   - Maintain clear loop conditions
   - Ensure proper initialization and termination

3. EARLY TERMINATION:
   - Use break or return when appropriate
   - Avoid unnecessary iterations

4. CLEAR VARIABLE NAMES:
   - Use descriptive names (index, current, max)
   - Make code self-documenting

5. CONSISTENT PATTERNS:
   - Follow standard iteration patterns
   - Use familiar loop structures

================================================================================

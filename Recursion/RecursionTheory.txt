================================================================================
                              RECURSION THEORY
================================================================================

OVERVIEW:
Recursion is a programming technique where a function calls itself to solve a problem.
It's based on the principle of mathematical induction and involves breaking down
a complex problem into smaller, similar subproblems.

FUNDAMENTAL COMPONENTS:
1. BASE CASE: The condition that stops the recursion
2. RECURSIVE CASE: The function calling itself with modified parameters

================================================================================
                         RECURSION TECHNIQUES & PATTERNS
================================================================================

1. DIRECT RECURSION
   - Function calls itself once
   - Example: factorial(n) = n * factorial(n-1)
   - Use Cases: Mathematical calculations, simple iterative problems

2. INDIRECT RECURSION
   - Function A calls function B, which calls function A
   - Example: Mutual recursion between two functions
   - Use Cases: State machines, parsing algorithms

3. TAIL RECURSION
   - Recursive call is the last statement
   - Can be optimized by compilers
   - Example: Tail-recursive factorial
   - Use Cases: Functional programming, optimization scenarios

4. HEAD RECURSION
   - Recursive call is made before other operations
   - Example: Printing numbers in reverse order
   - Use Cases: Processing data in reverse order

5. TREE RECURSION
   - Function calls itself more than once
   - Example: Fibonacci sequence
   - Use Cases: Tree traversal, combinatorial problems

6. NESTED RECURSION
   - Recursive call inside another recursive call
   - Example: Ackermann function
   - Use Cases: Complex mathematical functions

7. BACKTRACKING
   - Try all possible solutions, backtrack when dead end
   - Example: N-Queens problem, Sudoku solver
   - Use Cases: Constraint satisfaction problems

8. DIVIDE AND CONQUER
   - Break problem into smaller subproblems
   - Example: Merge sort, quick sort
   - Use Cases: Sorting, searching algorithms

9. MEMOIZATION (TOP-DOWN DP)
   - Store results of expensive function calls
   - Example: Fibonacci with cache
   - Use Cases: Dynamic programming optimization

10. TABULATION (BOTTOM-UP DP)
    - Build solution iteratively from smaller problems
    - Example: Iterative Fibonacci
    - Use Cases: Dynamic programming problems

11. RECURSION WITH STATE TRACKING
    - Pass additional parameters to track state
    - Example: Path finding with current path
    - Use Cases: Graph traversal, path problems

12. TERMINATION CONDITION DESIGN
    - Proper base case design to avoid infinite recursion
    - Example: Checking for valid input ranges
    - Use Cases: All recursive algorithms

13. RECURSIVE DEPTH MANAGEMENT
    - Control recursion depth to avoid stack overflow
    - Example: Setting maximum recursion depth
    - Use Cases: Deep recursive problems

14. RECURSION-TO-ITERATION CONVERSION
    - Convert recursive algorithm to iterative using stack
    - Example: Iterative tree traversal
    - Use Cases: Stack overflow prevention

15. MUTUAL RECURSION
    - Multiple functions call each other
    - Example: Even/odd checking functions
    - Use Cases: Complex state transitions

================================================================================
                            PRACTICAL APPLICATIONS
================================================================================

MATHEMATICAL COMPUTATIONS:
- Factorial calculation
- Fibonacci sequence
- Power calculation
- Greatest Common Divisor (GCD)

TREE OPERATIONS:
- Tree traversal (inorder, preorder, postorder)
- Tree height calculation
- Tree search operations

GRAPH ALGORITHMS:
- Depth-First Search (DFS)
- Path finding algorithms
- Topological sorting

SORTING ALGORITHMS:
- Merge sort
- Quick sort
- Heap sort

SEARCHING ALGORITHMS:
- Binary search
- Tree search
- Graph search

COMBINATORIAL PROBLEMS:
- Permutations and combinations
- Subset generation
- N-Queens problem

================================================================================
                        ADVANTAGES AND DISADVANTAGES
================================================================================

ADVANTAGES:
- Clean and readable code
- Natural solution for recursive problems
- Mirrors mathematical definitions
- Elegant for tree/graph problems

DISADVANTAGES:
- High memory usage (function call stack)
- Potential stack overflow
- Performance overhead
- Difficult to debug

================================================================================
                            BEST PRACTICES
================================================================================

1. Always define a clear base case
2. Ensure progress toward base case
3. Consider iterative alternatives for simple cases
4. Use memoization for overlapping subproblems
5. Monitor recursion depth
6. Test with small inputs first
7. Consider tail recursion optimization
8. Use proper variable naming for clarity

================================================================================
                              COMPLEXITY ANALYSIS
================================================================================

TIME COMPLEXITY:
- Linear recursion: O(n)
- Binary recursion: O(2^n)
- Tail recursion: O(n)
- With memoization: Often O(n)

SPACE COMPLEXITY:
- Function call stack: O(depth)
- Additional storage: Depends on algorithm
- Tail recursion: O(1) if optimized

================================================================================
                           COMMON PITFALLS
================================================================================

1. Missing base case (infinite recursion)
2. Incorrect base case condition
3. Not making progress toward base case
4. Stack overflow with deep recursion
5. Inefficient repeated calculations
6. Complex recursive relations
7. Debugging difficulties

================================================================================

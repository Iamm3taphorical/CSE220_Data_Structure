================================================================================
                                TREES THEORY
================================================================================

OVERVIEW:
Trees are hierarchical data structures consisting of nodes connected by edges.
They represent hierarchical relationships and are fundamental in computer science
for organizing data efficiently. A tree has a root node and zero or more subtrees.

FUNDAMENTAL PROPERTIES:
1. One root node (no parent)
2. Each node has zero or more child nodes
3. Each child has exactly one parent
4. No cycles exist in the structure
5. Connected and acyclic graph

================================================================================
                              TREE TERMINOLOGY
================================================================================

ROOT: The topmost node in a tree
PARENT: A node that has children
CHILD: A node that has a parent
LEAF: A node with no children
INTERNAL NODE: A node with at least one child
SIBLING: Nodes that share the same parent
ANCESTOR: All nodes on the path from root to a node
DESCENDANT: All nodes in the subtree rooted at a node
HEIGHT: Maximum distance from root to any leaf
DEPTH: Distance from root to a specific node
LEVEL: All nodes at the same depth
DEGREE: Number of children of a node

================================================================================
                              TREE TYPES
================================================================================

1. BINARY TREE
   - Each node has at most two children
   - Left child and right child
   - Applications: Expression trees, decision trees

2. BINARY SEARCH TREE (BST)
   - Binary tree with ordering property
   - Left subtree values < root < right subtree values
   - Applications: Searching, sorting, databases

3. AVL TREE
   - Self-balancing BST
   - Height difference between subtrees ≤ 1
   - Applications: Databases, file systems

4. RED-BLACK TREE
   - Self-balancing BST with color properties
   - Guarantees O(log n) operations
   - Applications: Standard library implementations

5. HEAP
   - Complete binary tree with heap property
   - Max heap: parent ≥ children
   - Min heap: parent ≤ children
   - Applications: Priority queues, heap sort

6. TRIE (PREFIX TREE)
   - Tree for storing strings
   - Each path represents a word
   - Applications: Autocomplete, spell checkers

7. N-ARY TREE
   - Each node can have N children
   - Applications: File systems, organizational charts

8. B-TREE
   - Self-balancing tree for external storage
   - Multiple keys per node
   - Applications: Databases, file systems

================================================================================
                            BASIC OPERATIONS
================================================================================

1. CREATE/INITIALIZE
   - Create empty tree or single node
   - Initialize root pointer
   - Set up tree structure

2. INSERT
   - General Tree: Add node at specified position
   - BST: Insert according to BST property
   - Heap: Insert maintaining heap property
   - Time Complexity: O(log n) for balanced trees

3. DELETE
   - Leaf Node: Simply remove the node
   - One Child: Replace with child
   - Two Children: Replace with inorder successor/predecessor
   - Time Complexity: O(log n) for balanced trees

4. SEARCH
   - General Tree: DFS or BFS traversal
   - BST: Binary search approach
   - Time Complexity: O(log n) for BST, O(n) for general tree

5. FIND MIN/MAX
   - BST: Leftmost/rightmost node
   - General Tree: Complete traversal
   - Time Complexity: O(log n) for BST

6. FIND HEIGHT/DEPTH
   - Recursive calculation
   - Maximum path length from root
   - Time Complexity: O(n)

7. COUNT NODES/LEAVES
   - Traverse entire tree
   - Count specific node types
   - Time Complexity: O(n)

8. CHECK BALANCED
   - Verify height difference ≤ 1
   - Recursive height calculation
   - Time Complexity: O(n)

9. VALIDATE BST
   - Check BST property at each node
   - Use min/max bounds
   - Time Complexity: O(n)

10. MIRROR/INVERT
    - Swap left and right children
    - Recursive operation
    - Time Complexity: O(n)

================================================================================
                             TREE TRAVERSALS
================================================================================

1. INORDER (LEFT → ROOT → RIGHT)
   - Visit left subtree
   - Process current node
   - Visit right subtree
   - For BST: gives sorted order
   - Time Complexity: O(n)

2. PREORDER (ROOT → LEFT → RIGHT)
   - Process current node
   - Visit left subtree
   - Visit right subtree
   - Used for tree copying
   - Time Complexity: O(n)

3. POSTORDER (LEFT → RIGHT → ROOT)
   - Visit left subtree
   - Visit right subtree
   - Process current node
   - Used for tree deletion
   - Time Complexity: O(n)

4. LEVEL-ORDER (BREADTH-FIRST)
   - Visit nodes level by level
   - Uses queue data structure
   - Good for shortest path
   - Time Complexity: O(n)

5. ZIGZAG LEVEL ORDER
   - Alternate left-to-right and right-to-left
   - Uses stack or deque
   - Time Complexity: O(n)

6. SPIRAL/DIAGONAL TRAVERSAL
   - Visit nodes in spiral pattern
   - Complex traversal pattern
   - Time Complexity: O(n)

7. BOUNDARY TRAVERSAL
   - Left edge → leaves → right edge
   - Three separate traversals
   - Time Complexity: O(n)

================================================================================
                           ADVANCED OPERATIONS
================================================================================

1. LOWEST COMMON ANCESTOR (LCA)
   - Find common ancestor of two nodes
   - Various algorithms: naive, binary lifting
   - Time Complexity: O(log n) with preprocessing

2. DIAMETER OF TREE
   - Longest path between any two nodes
   - May or may not pass through root
   - Time Complexity: O(n)

3. SERIALIZE/DESERIALIZE
   - Convert tree to string representation
   - Reconstruct tree from string
   - Various formats: preorder, level-order

4. TREE TO DOUBLY LINKED LIST
   - Convert BST to sorted doubly linked list
   - Inorder traversal approach
   - Time Complexity: O(n)

5. PATH SUM PROBLEMS
   - Find paths with given sum
   - Root-to-leaf or any path
   - Time Complexity: O(n)

6. SUBTREE CHECKING
   - Check if one tree is subtree of another
   - String matching or tree traversal
   - Time Complexity: O(n*m)

7. ISOMORPHIC TREES
   - Check if trees have same structure
   - Recursive comparison
   - Time Complexity: O(n)

8. BALANCED BST CONSTRUCTION
   - Convert sorted array to balanced BST
   - Recursive middle element selection
   - Time Complexity: O(n)

9. TREE RECONSTRUCTION
   - Build tree from traversal sequences
   - Inorder + preorder/postorder
   - Time Complexity: O(n)

================================================================================
                            PRACTICAL APPLICATIONS
================================================================================

FILE SYSTEMS:
- Directory structure representation
- File organization and navigation
- Permission hierarchies

DATABASES:
- B-trees for indexing
- Query optimization
- Transaction processing

COMPILERS:
- Abstract syntax trees
- Expression evaluation
- Code generation

DECISION MAKING:
- Decision trees
- Game trees (minimax)
- AI and machine learning

NETWORKING:
- Routing algorithms
- Network topologies
- Spanning trees

GRAPHICS:
- Scene graphs
- Binary space partitioning
- Collision detection

================================================================================
                        ADVANTAGES AND DISADVANTAGES
================================================================================

ADVANTAGES:
- Hierarchical data representation
- Efficient searching (O(log n) for balanced trees)
- Dynamic size
- Natural recursive structure
- Various specialized variants

DISADVANTAGES:
- Can become unbalanced
- Extra memory for pointers
- Complex deletion operations
- No constant-time operations

================================================================================
                              COMPLEXITY ANALYSIS
================================================================================

BALANCED TREES (AVL, Red-Black):
- Search: O(log n)
- Insert: O(log n)
- Delete: O(log n)
- Space: O(n)

UNBALANCED TREES:
- Worst case: O(n) for all operations
- Best case: O(log n) for balanced portions
- Average case: O(log n) for random insertions

TRAVERSALS:
- All traversals: O(n) time, O(h) space
- Level-order: O(n) space for queue

================================================================================
                            BALANCING TECHNIQUES
================================================================================

AVL TREE ROTATIONS:
- Single rotation (LL, RR)
- Double rotation (LR, RL)
- Maintain balance factor

RED-BLACK TREE:
- Color-based balancing
- Rotation and recoloring
- Maintain color properties

SPLAY TREE:
- Self-adjusting tree
- Recently accessed nodes move to root
- Amortized O(log n) operations

================================================================================
                           IMPLEMENTATION TIPS
================================================================================

1. Always check for null pointers
2. Use helper methods for recursion
3. Maintain parent pointers if needed
4. Consider iterative alternatives for deep trees
5. Use proper base cases in recursion
6. Handle edge cases (empty tree, single node)
7. Test with balanced and unbalanced trees
8. Consider memory management

================================================================================
                             COMMON PITFALLS
================================================================================

1. Forgetting to handle null nodes
2. Incorrect recursion base cases
3. Memory leaks in deletion
4. Unbalanced tree degradation
5. Incorrect BST property maintenance
6. Stack overflow with deep recursion
7. Inefficient traversal algorithms
8. Improper handling of duplicate values

================================================================================

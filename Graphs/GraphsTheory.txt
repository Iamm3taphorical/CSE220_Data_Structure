================================================================================
                                GRAPHS THEORY
================================================================================

OVERVIEW:
Graphs are non-linear data structures consisting of vertices (nodes) and edges
that connect these vertices. They represent relationships between objects and
are fundamental in computer science for modeling networks, social connections,
transportation systems, and many other real-world problems.

FUNDAMENTAL COMPONENTS:
1. VERTICES (V): The nodes or points in the graph
2. EDGES (E): The connections between vertices
3. ADJACENCY: Relationship between connected vertices
4. PATH: Sequence of vertices connected by edges
5. CYCLE: Path that starts and ends at the same vertex

================================================================================
                              GRAPH TERMINOLOGY
================================================================================

VERTEX/NODE: A point in the graph
EDGE: A connection between two vertices
ADJACENT: Two vertices connected by an edge
INCIDENT: An edge connected to a vertex
DEGREE: Number of edges connected to a vertex
  - In-degree: Number of incoming edges (directed graph)
  - Out-degree: Number of outgoing edges (directed graph)
PATH: Sequence of vertices where each adjacent pair is connected by an edge
CYCLE: A path that starts and ends at the same vertex
CONNECTED: A graph where there's a path between every pair of vertices
COMPONENT: A maximal set of connected vertices
SUBGRAPH: A graph formed from a subset of vertices and edges

================================================================================
                                GRAPH TYPES
================================================================================

1. DIRECTED GRAPH (DIGRAPH)
   - Edges have direction
   - Edge (u,v) is different from (v,u)
   - Applications: Web links, dependency graphs

2. UNDIRECTED GRAPH
   - Edges have no direction
   - Edge (u,v) is same as (v,u)
   - Applications: Social networks, road maps

3. WEIGHTED GRAPH
   - Edges have associated weights/costs
   - Can be directed or undirected
   - Applications: Shortest path problems, cost optimization

4. UNWEIGHTED GRAPH
   - All edges have equal weight (usually 1)
   - Simpler algorithms possible
   - Applications: Connectivity problems

5. CYCLIC GRAPH
   - Contains at least one cycle
   - Can have multiple cycles
   - Applications: Circular dependencies

6. ACYCLIC GRAPH
   - Contains no cycles
   - Directed Acyclic Graph (DAG) is important
   - Applications: Task scheduling, dependency resolution

7. DENSE GRAPH
   - Many edges relative to vertices
   - |E| ≈ |V|²
   - Matrix representation efficient

8. SPARSE GRAPH
   - Few edges relative to vertices
   - |E| << |V|²
   - List representation efficient

9. COMPLETE GRAPH
   - Edge between every pair of vertices
   - |E| = |V|(|V|-1)/2 for undirected
   - Applications: All-pairs problems

10. BIPARTITE GRAPH
    - Vertices can be divided into two disjoint sets
    - Edges only between different sets
    - Applications: Matching problems

================================================================================
                            GRAPH REPRESENTATIONS
================================================================================

1. ADJACENCY MATRIX
   - 2D array of size V×V
   - matrix[i][j] = 1 if edge exists, 0 otherwise
   - Space complexity: O(V²)
   - Edge lookup: O(1)
   - Best for dense graphs

2. ADJACENCY LIST
   - Array of linked lists
   - Each vertex has list of adjacent vertices
   - Space complexity: O(V + E)
   - Edge lookup: O(degree)
   - Best for sparse graphs

3. EDGE LIST
   - List of all edges
   - Each edge stored as (u, v) pair
   - Space complexity: O(E)
   - Edge lookup: O(E)
   - Best for algorithms processing all edges

4. INCIDENCE MATRIX
   - 2D array of size V×E
   - matrix[i][j] = 1 if vertex i is incident to edge j
   - Space complexity: O(V×E)
   - Used in specialized algorithms

================================================================================
                             BASIC OPERATIONS
================================================================================

1. CREATE/INITIALIZE GRAPH
   - Set up vertex and edge data structures
   - Initialize adjacency matrix/list
   - Set graph properties (directed/undirected)

2. ADD EDGE
   - Connect two vertices
   - Update adjacency representation
   - Handle directed vs undirected cases
   - Time complexity: O(1) for matrix, O(1) for list

3. REMOVE EDGE
   - Disconnect two vertices
   - Update adjacency representation
   - Time complexity: O(1) for matrix, O(degree) for list

4. ADD VERTEX
   - Add new vertex to graph
   - Resize adjacency representation if needed
   - Time complexity: O(V) for matrix, O(1) for list

5. REMOVE VERTEX
   - Remove vertex and all incident edges
   - Update adjacency representation
   - Time complexity: O(V) for matrix, O(V+E) for list

6. CHECK EDGE EXISTENCE
   - Verify if edge exists between two vertices
   - Time complexity: O(1) for matrix, O(degree) for list

7. GET NEIGHBORS
   - Find all vertices adjacent to given vertex
   - Time complexity: O(V) for matrix, O(degree) for list

8. GET DEGREE
   - Count edges connected to vertex
   - Time complexity: O(V) for matrix, O(1) for list

9. TRANSPOSE GRAPH
   - Reverse all edge directions
   - Time complexity: O(V²) for matrix, O(V+E) for list

10. CLONE GRAPH
    - Create identical copy of graph
    - Time complexity: O(V²) for matrix, O(V+E) for list

================================================================================
                              GRAPH TRAVERSALS
================================================================================

1. DEPTH-FIRST SEARCH (DFS)
   - Explore as far as possible along each branch
   - Uses stack (explicit or recursion)
   - Time complexity: O(V + E)
   - Space complexity: O(V)
   - Applications: Topological sort, cycle detection

2. BREADTH-FIRST SEARCH (BFS)
   - Explore all neighbors before going deeper
   - Uses queue data structure
   - Time complexity: O(V + E)
   - Space complexity: O(V)
   - Applications: Shortest path, level-order traversal

3. TOPOLOGICAL SORT
   - Linear ordering of vertices in DAG
   - DFS-based or Kahn's algorithm
   - Time complexity: O(V + E)
   - Applications: Task scheduling, dependency resolution

4. CYCLE DETECTION
   - Directed Graph: Using DFS with recursion stack
   - Undirected Graph: Using DFS with parent tracking
   - Time complexity: O(V + E)
   - Applications: Deadlock detection, validation

================================================================================
                            PATHFINDING ALGORITHMS
================================================================================

1. DIJKSTRA'S ALGORITHM
   - Shortest path from source to all vertices
   - Works with non-negative weights
   - Uses priority queue
   - Time complexity: O((V + E) log V)
   - Applications: GPS navigation, network routing

2. BELLMAN-FORD ALGORITHM
   - Shortest path with negative weights
   - Detects negative cycles
   - Time complexity: O(V × E)
   - Applications: Currency arbitrage, network protocols

3. FLOYD-WARSHALL ALGORITHM
   - All-pairs shortest paths
   - Dynamic programming approach
   - Time complexity: O(V³)
   - Applications: Transitive closure, shortest paths

4. A* ALGORITHM
   - Heuristic-based pathfinding
   - Uses estimated cost to goal
   - Time complexity: depends on heuristic
   - Applications: Game AI, robotics

5. DFS-BASED PATH FINDING
   - Find all paths between vertices
   - Backtracking approach
   - Time complexity: can be exponential
   - Applications: Route enumeration

================================================================================
                         COMPONENTS AND STRUCTURES
================================================================================

1. CONNECTED COMPONENTS
   - Maximal sets of connected vertices
   - DFS/BFS from each unvisited vertex
   - Time complexity: O(V + E)
   - Applications: Network analysis, clustering

2. STRONGLY CONNECTED COMPONENTS (SCC)
   - Maximal sets where every vertex reaches every other
   - Kosaraju's or Tarjan's algorithm
   - Time complexity: O(V + E)
   - Applications: Web page ranking, social networks

3. MINIMUM SPANNING TREE (MST)
   - Connects all vertices with minimum total weight
   - Kruskal's or Prim's algorithm
   - Time complexity: O(E log V)
   - Applications: Network design, clustering

4. KRUSKAL'S ALGORITHM
   - Sort edges by weight
   - Add edges without creating cycles
   - Uses Union-Find data structure
   - Time complexity: O(E log E)

5. PRIM'S ALGORITHM
   - Start from arbitrary vertex
   - Add minimum weight edge to MST
   - Uses priority queue
   - Time complexity: O(E log V)

6. BIPARTITE CHECKING
   - Check if graph can be 2-colored
   - BFS/DFS with color assignment
   - Time complexity: O(V + E)
   - Applications: Matching, scheduling

7. BRIDGE DETECTION
   - Find edges whose removal disconnects graph
   - Tarjan's algorithm
   - Time complexity: O(V + E)
   - Applications: Network reliability

8. ARTICULATION POINT DETECTION
   - Find vertices whose removal disconnects graph
   - Tarjan's algorithm
   - Time complexity: O(V + E)
   - Applications: Network vulnerability

9. GRAPH COLORING
   - Assign colors to vertices
   - Adjacent vertices have different colors
   - NP-complete for optimal coloring
   - Applications: Register allocation, scheduling

10. UNION-FIND (DISJOINT SET)
    - Track connected components
    - Path compression and union by rank
    - Time complexity: O(α(V)) amortized
    - Applications: Kruskal's algorithm, connectivity

================================================================================
                            PRACTICAL APPLICATIONS
================================================================================

SOCIAL NETWORKS:
- Friend connections
- Community detection
- Influence propagation
- Recommendation systems

TRANSPORTATION:
- Route planning
- Traffic optimization
- Public transit systems
- Logistics networks

COMPUTER NETWORKS:
- Routing protocols
- Network topology
- Bandwidth optimization
- Fault tolerance

WEB AND INTERNET:
- Web crawling
- Page ranking
- Link analysis
- Search algorithms

BIOINFORMATICS:
- Protein interactions
- Gene regulatory networks
- Phylogenetic trees
- Drug discovery

GAME DEVELOPMENT:
- Pathfinding
- AI decision trees
- Map generation
- Game state representation

================================================================================
                        ADVANTAGES AND DISADVANTAGES
================================================================================

ADVANTAGES:
- Models real-world relationships
- Flexible data structure
- Rich algorithmic toolkit
- Scalable to large datasets
- Various specialized types

DISADVANTAGES:
- Can be complex to implement
- Some algorithms have high complexity
- Memory intensive for dense graphs
- Difficult to visualize large graphs
- Many problems are NP-complete

================================================================================
                              COMPLEXITY ANALYSIS
================================================================================

ADJACENCY MATRIX:
- Space: O(V²)
- Add/Remove vertex: O(V²)
- Add/Remove edge: O(1)
- Edge lookup: O(1)
- Neighbors: O(V)

ADJACENCY LIST:
- Space: O(V + E)
- Add vertex: O(1)
- Add edge: O(1)
- Remove vertex: O(V + E)
- Remove edge: O(degree)
- Edge lookup: O(degree)
- Neighbors: O(degree)

COMMON ALGORITHMS:
- DFS/BFS: O(V + E)
- Dijkstra: O((V + E) log V)
- Floyd-Warshall: O(V³)
- MST: O(E log V)
- Topological Sort: O(V + E)

================================================================================
                           IMPLEMENTATION STRATEGIES
================================================================================

1. Choose appropriate representation
2. Handle directed vs undirected cases
3. Consider weighted vs unweighted graphs
4. Implement efficient traversal algorithms
5. Use appropriate data structures (queue, stack, priority queue)
6. Handle disconnected components
7. Optimize for specific use cases
8. Consider memory constraints

================================================================================
                             COMMON PITFALLS
================================================================================

1. Incorrect handling of directed/undirected graphs
2. Not handling disconnected components
3. Infinite loops in cycle detection
4. Incorrect priority queue usage
5. Memory leaks in dynamic graphs
6. Not considering negative weight edges
7. Inefficient representation choice
8. Forgetting to mark vertices as visited

================================================================================
                              ADVANCED TOPICS
================================================================================

NETWORK FLOWS:
- Maximum flow algorithms
- Min-cut max-flow theorem
- Ford-Fulkerson algorithm
- Applications in optimization

GRAPH MATCHING:
- Maximum bipartite matching
- Stable marriage problem
- Applications in assignment

PLANAR GRAPHS:
- Graphs drawable without edge crossings
- Euler's formula
- Applications in circuit design

GRAPH ISOMORPHISM:
- Determining if two graphs are identical
- Complexity class GI
- Applications in pattern recognition

================================================================================
